import gmsh
import meshio

# mostly generated by chatGPT
def create_square_mesh(domain_length, n, m, elem_size, name='square_mesh'):
    gmsh.initialize()
    gmsh.model.add('square_mesh')

    # Step 1: Create points
    tag = 1
    points = {}
    for i in range(n + 1):
        for j in range(m + 1):
            x, y = (i * domain_length / n, j * domain_length / m)
            points[(i, j)] = gmsh.model.geo.addPoint(x, y, 0, elem_size)

    # Step 2: Create lines and surfaces
    subdomain_tags = {}
    boundary_lines = {'top': [], 'left': [], 'right': [], 'bottom': []}

    for i in range(n):
        for j in range(m):
            p1 = points[(i, j)]
            p2 = points[(i + 1, j)]
            p3 = points[(i + 1, j + 1)]
            p4 = points[(i, j + 1)]

            l1 = gmsh.model.geo.addLine(p1, p2)  # Bottom
            l2 = gmsh.model.geo.addLine(p2, p3)  # Right
            l3 = gmsh.model.geo.addLine(p3, p4)  # Top
            l4 = gmsh.model.geo.addLine(p4, p1)  # Left

            cl = gmsh.model.geo.addCurveLoop([l1, l2, l3, l4])
            surface = gmsh.model.geo.addPlaneSurface([cl])

            subdomain_tags[(i, j)] = surface

            # Store boundary lines
            if j == m - 1:  # Top boundary
                boundary_lines['top'].append((l3, (i + 0.5) * domain_length / n))
            if j == 0:  # Bottom boundary
                boundary_lines['bottom'].append(l1)
            if i == 0:  # Left boundary
                boundary_lines['left'].append(l4)
            if i == n - 1:  # Right boundary
                boundary_lines['right'].append(l2)

    # Step 3: Synchronize
    gmsh.model.geo.synchronize()

    # Step 4: Assign physical groups
    for i in range(n):
        for j in range(m):
            gmsh.model.addPhysicalGroup(2, [subdomain_tags[(i, j)]], tag=(i * m + j + 1))
            gmsh.model.setPhysicalName(2, i * m + j + 1, f'Subdomain_{i}_{j}')

    # **Boundary Condition Physical Groups**
    bc1, bc2, bc3, bc4, bc5 = [], [], [], [], []

    # Process top boundary, not that the bc inclusion is decieded by the midpoint position.
    for line, x_mid in boundary_lines['top']:
        if domain_length / 4 <= x_mid <= 3 * domain_length / 4:
            bc1.append(line)  # BC1: Middle top boundary
        else:
            bc2.append(line)  # BC2: Rest of the top boundary

    # Remaining boundary (left, right, bottom)
    bc3.extend(boundary_lines['left'])
    bc4.extend(boundary_lines['right'])
    bc5.extend(boundary_lines['bottom'])

    if bc1:
        gmsh.model.addPhysicalGroup(1, bc1, tag=101)
        gmsh.model.setPhysicalName(1, 101, 'BC1_Top_Middle')

    if bc2:
        gmsh.model.addPhysicalGroup(1, bc2, tag=102)
        gmsh.model.setPhysicalName(1, 102, 'BC2_Top_Sides')

    if bc3:
        gmsh.model.addPhysicalGroup(1, bc3, tag=103)
        gmsh.model.setPhysicalName(1, 103, 'BC3_Left')

    if bc4:
        gmsh.model.addPhysicalGroup(1, bc4, tag=104)
        gmsh.model.setPhysicalName(1, 104, 'BC4_Right')

    if bc5:
        gmsh.model.addPhysicalGroup(1, bc5, tag=105)
        gmsh.model.setPhysicalName(1, 105, 'BC5_Bottom')


    # Step 5: Generate triangular mesh
    gmsh.model.mesh.generate(2)

    # Step 6: Export
    gmsh.write(f'{name}.msh')
    gmsh.finalize()


def convert_to_xdmf(filename):
    # based on
    # https://jsdokken.com/dolfinx-tutorial/chapter3/subdomains.html#read-in-msh-files-with-dolfinx
    # and
    # https://github.com/jorgensd/dolfinx-tutorial/blob/v0.8.0/chapter3/subdomains.ipynb

    mesh_in = meshio.read(f"{filename}.msh")

    cell_types = ["triangle", "line"]
    filename_suffixes = {"triangle": '', "line": "boundary"}
    points = mesh_in.points[:, :2]  # cut the z-coordinates for 2d mesh TODO: use as parameter
    for cell_type in cell_types:
        cell_data = mesh_in.get_cell_data("gmsh:physical", cell_type)
        cells = mesh_in.get_cells_type(cell_type)
        out_mesh = meshio.Mesh(points=points, cells={cell_type: cells}, cell_data={"Domains": [cell_data]})
        name = f"{filename}_{filename_suffixes[cell_type]}" if filename_suffixes[cell_type] else f"{filename}"
        meshio.write(f"{name}.xdmf", out_mesh)
        print(f"Mesh written to files: {name}.xdmf, {name}.h5")

if __name__ == '__main__':
    # Parameters
    L = 10.0  # Square side length
    n, m = 10, 10  # Number of subdomains in x and y direction
    elem_size = 0.05  # Approximate element size

    create_square_mesh(L, n, m, elem_size)
    convert_to_xdmf('square_mesh')

